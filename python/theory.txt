### Data Structures ###
DS - different ways of organizing data on your computer to be used effectively.

### DS Types: ###
Primitive:
- basic data types that cannot be broken into simpler data types.
- have a fixed size and they are usually smaller in size than the non primitive data structures.
- simpler, used for simple operations
- represented in memory as simple values
- integers: whole numbers without decimal points
- float: numbers with the decimal points
- strings: sequence of the characters or symbols enclosed in quotation marks
- booleans: values that represent true or false.

Non-primitive:
- more complex and can be broken down into smaller data types.
- can be larger in size and can grow or shrink dynamically
- more complex and can be composed of multiple primitive data structures
- used for complex operations such as data manipulation, sorting or searching
- represented in memory as pointers to other memory locations
- derived from primitive data types by combining two or more primitive data structures. 
These data structures can be subdivided as linear and non-linear data structures.

Linear:
- are those in which the elements are arranged in a sequential order with each element connected to its adjacent elements. 
These data structures are used to represent a sequence of data where the order of elements is important. 
There are many linear data structures in Python: lists, tuples, arrays, linked lists, stacks and queue.

Non-linear:
- are those in which the elements are not arranged in a sequential order. These DS are used to represent 
a hierarchical relationship between data elements where each element is connected to one or more other 
elements in a specific way. Sets, dictionaries, trees and graphs.

Built-in:
- come with Python. We don't need to use any external library or create these DSs ourselves.They are built in in Python.
- linear DS: lists and tuples are built in DS
- non linear DS: sets and dictionaries are built in DS

User Defined:
- we need to use some external library or we can create them ourselves to be able to use them.

### Algorithms ###
algorithm - a set of instruction to complete a task.

### Types of Algorithms ###
Sorting: 
- used to store data in ascending or descending order
- bubble sort, selection sort, insertion sort and so on.

Searching: 
- used to find a specific value in a data set.
- linear search, binary search and some other searching algorithms.

Graph: 
- to work with data that can be represented as graph.
- depth first search, breadth first search and Dijkstra's algorithms (the most famous graph algorithms).

Dynamic programming: 
- used to solve problems by breaking them down into the smaller subproblems.
- knapsack problems

Divide and conquer: 
- used to solve problems by breaking them down in smaller subproblems,
solving each sub problem independently and combining the results.
- merge-sort or quicksort

Recursion: 
- used to solve the problems by breaking them down in smaller sub-problems that are in a similar nature.


Big O 
- the language and metric we use to describe the efficiency of algorithms.
- shows how the runtime of the function increases as the size of the input increases.
- we are measuring the number of operations and space complexity.

Space Complexity: 
- the amount of the memory that some code used.

Big O Notations
- Best Case: Omega
- Average Case: Big Theta
- Worst Case: Big O

Runtime Complexity
Linear Time Complexity
- time complexity will grow in direct proportion to the size of input data.

Drop Constants
- it is very possible that O(n) code is faster than O(1) code for specific input, 
but big O just describes the rate of increase.
- different computers with different architectures have different constant factors.
However, we are just interested in the algorithm, not the hardware when doing the 
asymptotic analysis, so we ignore such constant factors.
